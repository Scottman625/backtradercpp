(* Content-type: application/vnd.wolfram.mathematica *)

(*** Wolfram Notebook File ***)
(* http://www.wolfram.com/nb *)

(* CreatedBy='Mathematica 13.1' *)

(*CacheID: 234*)
(* Internal cache information:
NotebookFileLineBreakTest
NotebookFileLineBreakTest
NotebookDataPosition[       158,          7]
NotebookDataLength[     11266,        232]
NotebookOptionsPosition[     10021,        202]
NotebookOutlinePosition[     10433,        218]
CellTagsIndexPosition[     10390,        215]
WindowFrame->Normal*)

(* Beginning of Notebook Content *)
Notebook[{
Cell[BoxData[{
 RowBox[{
  RowBox[{"SetDirectory", "[", 
   RowBox[{"NotebookDirectory", "[", "]"}], "]"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"file", "=", 
   RowBox[{"Import", "[", 
    RowBox[{"\"\<ReadMe-template.md\>\"", ",", "\"\<text\>\""}], "]"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{"WriteString", "[", 
  RowBox[{"\"\<ReadMe.md\>\"", ",", 
   RowBox[{"StringReplace", "[", 
    RowBox[{"file", ",", 
     RowBox[{
      RowBox[{"\"\<![[\>\"", "~~", 
       RowBox[{"Shortest", "[", "x__", "]"}], "~~", "\"\<]]\>\""}], ":>", 
      RowBox[{"Import", "[", 
       RowBox[{"x", ",", "\"\<Text\>\""}], "]"}]}]}], "]"}]}], 
  "]"}], "\[IndentingNewLine]"}], "Input",
 CellChangeTimes->{{3.8718018288903627`*^9, 3.871801893681295*^9}, {
   3.872059129467784*^9, 3.8720591816977444`*^9}, 3.8720592669936466`*^9},
 CellLabel->"In[13]:=",ExpressionUUID->"92ae036a-e4cd-42b7-81dc-731365bc4de5"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"StringReplace", "[", 
  RowBox[{"\"\<xx![[ff]]\>\"", ",", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{
     "RegularExpression", "[", "\"\<\\\\!\\\\[\\\\[(^\\\\]+)\\\\]\\\\]\>\"", 
      "]"}], "->", "\"\<\>\""}], "}"}]}], "]"}]], "Input",
 CellChangeTimes->{{3.8718019898680305`*^9, 3.8718020466406555`*^9}, {
  3.8718020774225683`*^9, 3.871802098787753*^9}, {3.8718021539705143`*^9, 
  3.87180221830661*^9}, {3.871802269273806*^9, 3.8718022916847935`*^9}, {
  3.871802366435565*^9, 3.871802377713797*^9}},
 CellLabel->"In[19]:=",ExpressionUUID->"6fc61378-ce78-40e7-b85f-50d5e4c5a891"],

Cell[BoxData["\<\"xx![[ff]]\"\>"], "Output",
 CellChangeTimes->{{3.8718022014810286`*^9, 3.8718022190068827`*^9}, {
   3.871802270093628*^9, 3.8718022924101343`*^9}, 3.8718023786389494`*^9},
 CellLabel->"Out[19]=",ExpressionUUID->"e505a1de-4afd-4873-b02b-3eae078a8318"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"StringReplace", "[", 
  RowBox[{"\"\<xx![[f]]\>\"", ",", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"RegularExpression", "[", "\"\<\\\\!\\\\[\>\"", "]"}], "->", 
     "\"\<\>\""}], "}"}]}], "]"}]], "Input",
 CellChangeTimes->{{3.871802198473812*^9, 3.8718022272414618`*^9}},
 CellLabel->"In[16]:=",ExpressionUUID->"80b44336-2650-4e4c-a1a1-9f5bdead4abe"],

Cell[BoxData["\<\"xx[f]]\"\>"], "Output",
 CellChangeTimes->{
  3.871802046978233*^9, {3.871802085922821*^9, 3.8718021061089735`*^9}, {
   3.8718021569443636`*^9, 3.8718022279271545`*^9}},
 CellLabel->"Out[16]=",ExpressionUUID->"b339e5ed-e434-440b-a9d7-57db084c7df9"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"StringReplace", "[", 
  RowBox[{"\"\<xx(aabc)\>\"", ",", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"RegularExpression", "[", "\"\<\\\\(([^b]+)\>\"", "]"}], "->", 
     "\"\<\>\""}], "}"}]}], "]"}]], "Input",
 CellChangeTimes->{{3.8718020043247843`*^9, 3.8718020084744835`*^9}, {
   3.8718023868486147`*^9, 3.8718025079271774`*^9}, {3.871802706322393*^9, 
   3.8718028040822153`*^9}, 3.8718029252393236`*^9},
 CellLabel->"In[39]:=",ExpressionUUID->"a800a422-bd43-4d94-8c0f-0d4d9e801afa"],

Cell[BoxData["\<\"xxbc)\"\>"], "Output",
 CellChangeTimes->{{3.871802410217327*^9, 3.871802508446828*^9}, {
   3.8718027105510874`*^9, 3.8718027588869724`*^9}, 3.8718027930143976`*^9, 
   3.8718029263896184`*^9},
 CellLabel->"Out[39]=",ExpressionUUID->"59798f74-cc23-4be0-b384-ec63bd39a48f"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"StringReplace", "[", 
  RowBox[{"file", ",", 
   RowBox[{
    RowBox[{"\"\<![[\>\"", "~~", 
     RowBox[{"Shortest", "[", "x__", "]"}], "~~", "\"\<]]\>\""}], ":>", 
    RowBox[{"Import", "[", 
     RowBox[{"x", ",", "\"\<Text\>\""}], "]"}]}]}], "]"}]], "Input",
 CellChangeTimes->{{3.871802998297973*^9, 3.8718030345497026`*^9}, {
  3.8718030667127943`*^9, 3.871803076757267*^9}, {3.8718031652940054`*^9, 
  3.8718031707804356`*^9}, {3.8720591997178416`*^9, 3.8720592009575615`*^9}, {
  3.872059243581193*^9, 3.8720592548752327`*^9}},
 CellLabel->"In[6]:=",ExpressionUUID->"7a71364e-6e5c-490c-a7eb-5209deb5f1af"],

Cell[BoxData["\<\"# backtradercpp -- A header-only C++ 20 back testing \
library\\n\\nAs the name suggests, this library is partially inspired by \
`backtrader` of python. However `backtrader` constantly made me confusing so \
I decide to write my own library.\\n\\n## Install\\nIt's a header only \
library. However you need to install some dependencies. On \
windows:\\n```\\n./vcpkg install boost:x64-windows eigen3:x64-windows \
fmt:x64-windows\\n```\\n\\n\\n## Example\\nSee `vs_examples`.\\n\\n### Most \
basic example\\n\\n```cpp\\n#include <iostream>\\n#include \
\\\"../../include/backtradercpp/Cerebro.hpp\\\"\\nusing namespace \
backtradercpp;\\nusing namespace std;\\n\\nstruct SimpleStrategy : \
strategy::GenericStrategy {\\n    void run() override {\\n        // Buy \
assets at 5th day.\\n        if (i == 5) {\\n            for (int j = 0; j < \
data(0).assets(); ++j) {\\n                if (data(0).valid(-1, j)) {\\n     \
               // Buy 10 asset j at the price of latest day(-1) on the broker \
0.\\n                    buy(0, j, data(0).open(-1, j), 10);\\n               \
 }\\n            }\\n        }\\n        ++i;\\n    }\\n\\n    int i = \
1;\\n};\\nint main() {\\n    Cerebro cerebro;\\n    // non_delimit_date is a \
function that convert date string like \\\"20200101\\\" to standard \
format.\\n    //  0.0005 and 0.001 are commission rate for long and short \
trading.\\n    cerebro.add_data(\\n        \
std::make_shared<feeds::CSVTabularData>(\\\"../../example_data/CSVTabular/\
djia.csv\\\",\\n                                                \
feeds::TimeStrConv::non_delimited_date),\\n        \
std::make_shared<broker::Broker>(0.0005, 0.001),);\\n    \
cerebro.set_strategy(std::make_shared<SimpleStrategy>());\\n    \
cerebro.run();\\n}\\n```\\n\\n### Equal weight strategy\\n\\n```\\n#include \
\\\"../../include/backtradercpp/Cerebro.hpp\\\"\\nusing namespace \
backtradercpp;\\n\\nstruct EqualWeightStrategy : strategy::GenericStrategy \
{\\n    void run() override {\\n        // Re-adjust to equal weigh each 30 \
trading days.\\n        if (time_index() % 30 == 0) {\\n            \
adjust_to_weight_target(0, VecArrXd::Constant(assets(0), 1. / assets(0)));\\n \
       }\\n    }\\n};\\n\\nint main() {\\n    Cerebro cerebro;\\n    \
cerebro.add_data(\\n        \
std::make_shared<feeds::CSVTabularData>(\\\"../../example_data/CSVTabular/\
djia.csv\\\",\\n                                                \
feeds::TimeStrConv::delimited_date),\\n        \
std::make_shared<broker::Broker>(10000, 0.0005, 0.001), 2); // 2 for \
window\\n    \
cerebro.set_strategy(std::make_shared<EqualWeightStrategy>());\\n    \
cerebro.run();\\n}\\n```\\n\\n### Stop on loss and profit\\n\\n```\\n#include \
\\\"../../include/backtradercpp/Cerebro.hpp\\\"\\nusing namespace \
backtradercpp;\\n\\nstruct SimpleStrategy : strategy::GenericStrategy {\\n    \
void run() override {\\n        // Do nothing at initial 30 days.\\n        \
if (time_index() < 30) {\\n            return;\\n        }\\n        // If \
daily return larger than 0.05, then buy.\\n        for (int j = 0; j < \
data(0).assets(); ++j) {\\n            if (data(0).valid(-1, j)) {\\n         \
       double p = data(0).close(-1, j), old_p = data(0).close(-2, j);\\n      \
          if ((old_p > 0) && ((p / old_p) > 1.05))\\n                    // \
Issue an order of buy at the price of open on next day.\\n                    \
delayed_buy(0, j, EvalOpen::exact(), 10);\\n            }\\n        }\\n      \
  // Sell on broker 0 if profits or loss reaching target.\\n        // Price \
is open of next day.\\n        for (const auto &[asset, item] : \
portfolio_items(0)) {\\n            if (item.profit > 1500 || item.profit < \
-1000) {\\n                close(0, asset, EvalOpen::exact());\\n            \
}\\n        }\\n    }\\n};\\n\\nint main() {\\n    Cerebro cerebro;\\n\\n    \
cerebro.add_data(\\n        \
std::make_shared<feeds::CSVTabularData>(\\\"../../example_data/CSVTabular/\
djia.csv\\\",\\n                                                \
feeds::TimeStrConv::non_delimited_date),\\n        \
std::make_shared<broker::Broker>(10000, 0.0005, 0.001), 2); // 2 for \
window\\n    cerebro.set_strategy(std::make_shared<SimpleStrategy>());\\n    \
cerebro.run();\\n}\\n```\\n\\n## Important Notes\\n\\n1. Please use \
**backward adjusted** data (keep oldest value fixed and adjust following \
data). When you buy, use **raw price**. I developed an algorithm to deal with \
backward adjusted data. The core idea is to track the profits under raw price \
(profti) and adjusted price (dyn_adj_profit). Then the differen `adj_profit - \
profit` is profits due to external factors. Total wealth will \
be\\n```\\ntotal wealth = cash + asset value under raw price + \
(dyn_adj_profit - profit)\\n```\\nWhen you sell, a propotion of difference \
`dyn_adj_profit - profit` will be added to your cash.\\n\\nDue to forward \
adjuted prices (keep newest price fixed and adjust older data) may be \
negative, I'm not sure if my algorithm will work at this case.\\n## Code \
Structure\\n1. Generic(FeedData) -> FeedAggragator(FullAssetData)\"\>"], \
"Output",
 CellChangeTimes->{{3.87180301137361*^9, 3.871803036431075*^9}, 
   3.8718030775959935`*^9, 3.871803171171974*^9, 3.87205920156965*^9, 
   3.872059255787012*^9},
 CellLabel->"Out[6]=",ExpressionUUID->"93e26d9f-42a3-4448-89ad-6007b19baef1"]
}, Open  ]]
},
WindowMargins->{{
  Automatic, 178.20000000000005`}, {-37.799999999999955`, Automatic}},
FrontEndVersion->"13.1 for Microsoft Windows (64-bit) (June 16, 2022)",
StyleDefinitions->"Default.nb",
ExpressionUUID->"bff269f8-6d5f-4463-b77e-3edf2af498d6"
]
(* End of Notebook Content *)

(* Internal cache information *)
(*CellTagsOutline
CellTagsIndex->{}
*)
(*CellTagsIndex
CellTagsIndex->{}
*)
(*NotebookFileOutline
Notebook[{
Cell[558, 20, 922, 22, 192, "Input",ExpressionUUID->"92ae036a-e4cd-42b7-81dc-731365bc4de5"],
Cell[CellGroupData[{
Cell[1505, 46, 610, 12, 52, "Input",ExpressionUUID->"6fc61378-ce78-40e7-b85f-50d5e4c5a891"],
Cell[2118, 60, 269, 3, 35, "Output",ExpressionUUID->"e505a1de-4afd-4873-b02b-3eae078a8318"]
}, Open  ]],
Cell[CellGroupData[{
Cell[2424, 68, 378, 8, 52, "Input",ExpressionUUID->"80b44336-2650-4e4c-a1a1-9f5bdead4abe"],
Cell[2805, 78, 267, 4, 35, "Output",ExpressionUUID->"b339e5ed-e434-440b-a9d7-57db084c7df9"]
}, Open  ]],
Cell[CellGroupData[{
Cell[3109, 87, 512, 10, 52, "Input",ExpressionUUID->"a800a422-bd43-4d94-8c0f-0d4d9e801afa"],
Cell[3624, 99, 291, 4, 35, "Output",ExpressionUUID->"59798f74-cc23-4be0-b384-ec63bd39a48f"]
}, Open  ]],
Cell[CellGroupData[{
Cell[3952, 108, 636, 12, 53, "Input",ExpressionUUID->"7a71364e-6e5c-490c-a7eb-5209deb5f1af"],
Cell[4591, 122, 5414, 77, 3657, "Output",ExpressionUUID->"93e26d9f-42a3-4448-89ad-6007b19baef1"]
}, Open  ]]
}
]
*)

